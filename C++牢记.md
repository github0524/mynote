C++

## 常问

### 顶层const和底层const

"顶层const"和"底层const"都是指const关键字在C++中的应用。

"顶层const"指的是const关键字修饰指针本身，即指针指向的地址不能修改，但指针本身的值（即指向的对象）可以修改。

问：一般变量是顶层const还是底层const

一般变量的const是顶层const。

因为底层const通常用于修饰指针类型或者引用类型，用于限制它们所指向的对象不可修改；而对于一般变量，我们更多的是希望限制其本身的值不可修改，而不是限制其所指向的对象不可修改。因此，在C++中，我们通常使用"顶层const"来实现一般变量的常量限制。

**总结**

顶层const就是修饰本身

底层const就是修饰指向的对象

一边只有指针用区分，普通的变量都是顶层const,特殊的，引用没有顶层const，因为自己只是一个别名，它是指向常量的引用，是个底层const

### 指针函数和函数指针

函数指针是指向函数的指针变量，它存储了函数在内存中的起始地址，可以通过函数指针来调用该函数。在回调函数的场景中，通常将一个函数的地址传递给另一个函数作为参数，以便后者在需要时调用前者。这种情况下，需要使用函数指针来完成这个过程。

*// 定义回调函数的函数签名*

typedef void (*Callback)(int);

指针函数是指返回指针类型的函数，它与回调函数的概念不同。虽然指针函数也可以用于回调的场合，但在一般情况下，使用函数指针更加符合语义和惯例。

*// 定义指针函数* 

int* create_array(int size)；



## 数组

### 复杂的数组声明

p102

理解里面的每个声明的意思，原则从函数名开始，**从右到左，从内到外**

<img src="image/C++牢记.assets/image-20230529152703554.png" alt="image-20230529152703554"  />

![image-20230529152928739](image/C++牢记.assets/image-20230529152928739.png)

### 数组的维度一定要是常量表达式

![image-20230529174422940](image/C++牢记.assets/image-20230529174422940.png)

之前这下面判断错了三道

![image-20230529174445609](image/C++牢记.assets/image-20230529174445609.png)

（a）非法，buf_size不是常量表达式  （c）非法，txt_size()函数返回值并不是常量表达式，返回值改为constexpr int  （d）非法，字符串字面值后自带'\0'，超出范围

### 不初始化数组导致的缓冲区溢出

![image-20230529175928691](image/C++牢记.assets/image-20230529175928691.png)

### 直接初始化和拷贝初始化

直接初始化不一定要调用复制构造函数，而复制初始化一定要调用复制构造函数

然而，大多数人却认为，直接初始化是构造对象时要调用复制构造函数，而复制初始化是构造对象时要调用赋值操作函数，这其实是一大误解，因为只有对象被创建时才出现初始化，而赋值操作并不应用于对象的创建过程。至于为什么会出现这个误解，可能是因为复制初始化的写法中存在等号（=）吧。

我们来看个例子

string  str1 = "first";    //拷贝初始化，编译器允许把这句话改写为string str(“first”)，但是string类必须有public的拷贝(移动)构造函数
string  str2(10,'a');     //直接初始化
string  str3(str2);      //直接初始化
string  str4 = string(10,'b');  //拷贝初始化
string  str5 = str4;        //拷贝初始化
string  str6 ("strr");       //直接初始化
如果误解调用拷贝构造函数的就是拷贝初始化，所以可能觉得str3也是拷贝初始化，这样就错了~

直接初始化：

使用普通的函数匹配就可以完成的初始化叫做直接初始化，
也就是说只是直接调用类的构造函数或者拷贝构造函数就能完成初始化的就是直接初始化。
而str2和str3分别调用构造函数和拷贝构造函数，因此它们是直接初始化
拷贝初始化：

将对象拷贝到正在创建的对象中，如果需要还要进行类型转换。
这里也就是间接调用拷贝构造函数，当然大部分情况调用拷贝构造函数，有时也可能调用移动构造函数。
根据上面的例子，我们可能觉得，只有等号"="出现时，才会是拷贝初始化。

其实不然，在下面三个情况下也会发生拷贝初始化。

将一个对象作为实参传递给一个非引用类型的实参(引用作为参数的话就可以省略拷贝这一操作，所以有时候可以这样来优化代码)
从一个返回类型为非引用的函数返回一个对象
花括号初始化一个数组的元素或一个聚合类（struct）的成员
————————————————
原文链接：https://blog.csdn.net/zhizhengguan/article/details/114951840

数组的首尾获取迭代

![image-20230529182243422](image/C++牢记.assets/image-20230529182243422.png)

### 数组和vector

不能直接使用vector初始化数组，但是可以使用数组初始化vector

![image-20230530113021019](image/C++牢记.assets/image-20230530113021019.png)

也可以修改起始和尾后位置，只要数组的一部分，但是注意最后一个是尾后指针，不算。

此外C++中提倡使用vector和迭代器，不推荐使用内置数组和指针

![image-20230530113211187](image/C++牢记.assets/image-20230530113211187.png)

## 运算符

**->箭头运算符**，综合了解引用运算符和点运算符

a->b等价于(*a).b



**指针不能相加**

两个指针相减表示两个指针相距的距离。但是两个指针相加并没有任何逻辑上的意义，因此两个指针不能相加



## 字符串

### 分清楚标准库的string字符串类型和C风格的字符串类型

C风格的字符串类型已空字符结尾\0

1.注意下面有个C风格字符串的操作例子，这些函数如果没有以\0结尾，会错

![image-20230529194026855](image/C++牢记.assets/image-20230529194026855.png)

2.标准库的string类型对象能够使用+运算符连接，但是C风格的不行，这是表示一个指针（char p[]）

但是如果加号任意一边有一个string对象就可以，而且运算时C风格字符串会被转化为string类型，空字符串会被消除



<img src="image/C++牢记.assets/image-20230530100802103.png" alt="image-20230530100802103" style="zoom:80%;" />

<img src="image/C++牢记.assets/image-20230530101008673.png" alt="image-20230530101008673"  />

3.比较字符串

![image-20230529194733773](image/C++牢记.assets/image-20230529194733773.png)

4.string类型和C风格字符串类型的转化

string str(“hello”);****

**这里一定要注意的是返回的指针是指向str的地址的，const是为了这个数组不能反向的去改变原来string类型的值，但是如果string自己改变了值，那么这个返回的C风格数组指针指向的内容也变了，所以，如果想返回的这些数据可以单独使用，最好将数据拷贝后再使用。**

const char* mystr = str.c_str()，在这里**注意要加上const**，因为c_str()返回的是const char *类型

## 第四章 运算符

求值顺序

有些运算符并没有规定求值的顺序，所以行为不可预测，比如<<

![image-20230530141204872](image/C++牢记.assets/image-20230530141204872.png)

​	

![image-20230530141235863](image/C++牢记.assets/image-20230530141235863.png)

练习

![image-20230530143057457](image/C++牢记.assets/image-20230530143057457.png)

复合赋值运算符

![image-20230530143734261](image/C++牢记.assets/image-20230530143734261.png)

### 解引用运算符和自增运算符

![image-20230530144211597](image/C++牢记.assets/image-20230530144211597.png)

### 解引用运算符和点运算符

![image-20230530145026171](image/C++牢记.assets/image-20230530145026171.png)

### C++运算符优先级表

cout << 与移位运算符差不多

<img src="image/C++牢记.assets/image-20230530160208187.png" alt="image-20230530160208187" style="zoom:80%;" />

![image-20230530160339646](image/C++牢记.assets/image-20230530160339646.png)

![image-20230530160408528](image/C++牢记.assets/image-20230530160408528.png)

## 第五章 语句

### 范围for语句

C++11新标准引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。范围for语句range for statement 的语句形式是

for(declaration : expression)

​	statement

vector<int> v = {0,1,2,3,4,5,6,7,8,9};

for(auto &r : v)

​	r *= 2;

try{



}catch( ){

throw

}

## 第六章 函数

函数的调用运算符是一对圆括号( )

### 形参和实参

实参和形参的区别的什么？

解：

实参是函数调用的实际值，是形参的初始值。

### 局部静态变量

可以发现这个静态变量贯穿了程序的始终，每次调用这个函数的值都是一个变量

![image-20230530181818525](image/C++牢记.assets/image-20230530181818525.png)

### 引用传递和值传递

- **引用传递**（passed by reference）：又称传引用调用（called by reference），指**形参是引用类型**，引用形参是它对应的实参的别名。
- **值传递**（passed by value）：又称传值调用（called by value），指实参的值是通过**拷贝**传递给形参。

### C++推荐用引用访问函数外部对象

而不是C中使用指针类型的形参访问

### 传引用参数

注意下面的这种写法，形参是一个引用，但是传入的是一个对象，形参不过是一个别名，形参的改变也会影响实参对象。引用应该时刻记住，翻译成别名

![image-20230531104552550](image/C++牢记.assets/image-20230531104552550.png)

**引用形参使用场景**

1.避免拷贝，比如要比较两个string类型的长度，但是由于字符串非常长，应避免直接拷贝他们，**所以使用引用形参是比较明智的选择**

2.返回值更多，return一般只能返回一个值，如果都要放到里面可能比较，可以使用引用形参返回。

3.如果传入的引用形参不需要改变对象的值，最好声明为const常量类型
